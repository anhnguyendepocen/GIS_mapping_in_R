{"name":"Intro to GIS mapping in R","tagline":"Plot your study site!","body":"## Motivation\r\nThere are many software solutions that will allow you to make a map. Some of them are free and open source (_e.g._ [GRASS](grass.osgeo.org/)) or not (_e.g._ [ArcGIS](http://www.arcgis.com/features/)). The argument between R and something that isn't free is pretty self explanatory, but why would we want to do our GIS tasks in R over something else like GRASS that was designed for this purpose? My usual answer to that is that I prefer a nice workflow all in R, I like the continuity. I also like leveraging my R programming know-how (e.g. data manipulation, loops, etc) to do complex and/or repeated operations that might take me longer to click through or learn how to automate in some other program.\r\nReally, you just need to find the right tool for the job, sometimes that will be R, other times it will be a dedicated GIS program. Also, R and GRASS can [interact](http://grasswiki.osgeo.org/wiki/R_statistics) providing an intermediate solution. All that being said, it helps to know what R can do when you're choosing your tool.\r\n\r\n## Load the required packages\r\n\r\n    library(maptools)\r\n    library(rgdal)\r\n    library(raster)\r\n    library(maps)\r\n    library(mapdata)\r\n    library(ggmap)\r\n    library(marmap)\r\n    library(lattice)\r\n\r\n## Getting your data off your GPS\r\nIf your GPS can export to `.gpx` format, you can read the file directly as lines (i.e. `tracks`), points (i.e. `track_points`), and a few other formats you can find in the help for `readOGR`:\r\n\r\n    run <- readOGR(dsn=\"run.gpx\",layer=\"tracks\")\r\n    plot(run)\r\n    \r\n    run <- readOGR(dsn=\"run.gpx\",layer=\"track_points\")\r\n    plot(run)\r\n\r\nIf your GPS cannot save in `.gpx` format, you will have to resort to [GPSBabel](http://www.gpsbabel.org/) to convert your file(s) from the proprietary file format to `.gpx`. Interestingly, to streamline your workflow and make your work reproducible, R can interact with GPSBabel directly through the [`readGPS()`](http://www.inside-r.org/packages/cran/maptools/docs/readGPS) function which is in the `maptools` package\r\n    \r\n## Getting a base map\r\nThere are a few ways to get this type of thing in R, I'll cover many of these in a future lesson, for now let's just use a simple world map from the maptools package:\r\n\r\n    data(wrld_simpl)\r\n    \r\n\r\nLet's plot that to see what we have\r\n    \r\n    plot(wrld_simpl)\r\n\r\nOr we can 'zoom in' on a particular spot if we provide limits\r\n    \r\n    xlim=c(-130,-60)\r\n    ylim=c(45,80)\r\n    plot(wrld_simpl,xlim=xlim,ylim=ylim)\r\n\r\nWe can also give it some color\r\n    \r\n    plot(wrld_simpl,xlim=xlim,ylim=ylim,col='olivedrab3',bg='lightblue')\r\n    \r\nI know, the map projection is not awesome, we're going to cover that in another future lesson. \r\n    \r\n## Exporting and importing\r\nNow that we know how to get a super basic map in R, let's look at how we can export and import data. This will write an ArcGIS compatible shapefile, `writeOGR()` will actually write to many different formats you just need to find the correct `driver`\r\n    \r\n    writeOGR(wrld_simpl,dsn=getwd(), layer = \"world_test\", driver = \"ESRI Shapefile\", overwrite_layer = TRUE)\r\n    \r\nNow we could open `world_test.shp` in ArcGIS, but we can also import shapefiles back into R, let's use that same file\r\n    \r\n    world_shp <- readOGR(dsn = getwd(),layer = \"world_test\")\r\n    plot(world_shp)\r\n    \r\n## Spatial data types in R\r\n### Vector based (points, lines, and polygons)\r\ncreating spatial data from scratch in R seems a little convoluted to me, but once you understand the pattern, it gets easier\r\n\r\n#### SpatialPointsDataFrame\r\nlet's plot points on Simon Fraser University and University of Toronto\r\n    \r\n    coords <- matrix(c(-122.92,-79.4, 49.277,43.66),ncol=2)\r\n    coords <- coordinates(coords)\r\n    spoints <- SpatialPoints(coords)\r\n    df <- data.frame(location=c(\"SFU\",\"UofT\"))\r\n    spointsdf <- SpatialPointsDataFrame(spoints,df)\r\n    plot(spointsdf,add=T,col=c('red','blue'),pch=16)\r\n    \r\n#### SpatialLinesDataFrame\r\nlet's plot the borders of the province of Saskatchewan because they're easy to draw (but not to spell!)\r\n    \r\n    coords <- matrix(c(-110,-102,-102,-110,-110,60,60,49,49,60),ncol=2)\r\n    l <- Line(coords)\r\n    ls <- Lines(list(l),ID=\"1\")\r\n    sls <- SpatialLines(list(ls))\r\n    df <- data.frame(province=\"Saskatchewan\")\r\n    sldf <- SpatialLinesDataFrame(sls,df)\r\n    plot(sldf,add=T,col='black') \r\n  \r\n#### SpatialPolygonsDataFrame\r\nlet's plot the province of Saskatchewan because it's easy to draw (but not to spell!)\r\n    \r\n    coords <- matrix(c(-110,-102,-102,-110,-110,60,60,49,49,60),ncol=2)\r\n    p <- Polygon(coords)\r\n    ps <- Polygons(list(p),ID=\"1\")\r\n    sps <- SpatialPolygons(list(ps))\r\n    df <- data.frame(province=\"Saskatchewan\")\r\n    spdf <- SpatialPolygonsDataFrame(sps,df)\r\n    plot(spdf,add=T,col='red')  \r\n    \r\n## Making nicer maps\r\n    \r\n    coords <- matrix(c(-61,-62,-62,-61,-61,46,46,45,45,46),ncol=2)\r\n    p <- Polygon(coords)\r\n    ps <- Polygons(list(p),ID=\"1\")\r\n    sps <- SpatialPolygons(list(ps))\r\n    df <- data.frame(province=\"Saskatchewan\")\r\n    spdf <- SpatialPolygonsDataFrame(sps,df)\r\n    plot(spdf,add=T,col='red') \r\n    \r\n##### The `raster` package for basic maps that interact well with spatial objects we used above, unlike many other packages, this method 'plays nice' with other spatial object from the `sp` package and can be use proper projections etc.\r\nWe can download polygons for Canada from [GADM](http://gadm.org/about) (amongst other sources) with the country code `\"CAN\"`, and level=1 indicates provinces, `0` would be the whole country.\r\n    \r\n    Canada <- getData('GADM', country=\"CAN\", level=1)\r\n    plot(Canada)\r\n    \r\nWe can manipulate this `SpatialPolygonDataFrame` by looking at what is inside its dataframe\r\n    \r\n    Canada@data\r\n\r\nWe can see that the names of the provinces are in `Canada@data$NAME_1`, so lets use that to extract provinces\r\n\r\n    NS <- Canada[Canada@data$NAME_1==\"Nova Scotia\",]\r\n    plot(NS,col=\"blue\")\r\n    \r\n    NB <- Canada[Canada@data$NAME_1==\"New Brunswick\",]\r\n    plot(NB,col=\"yellow\",add=TRUE)\r\n    \r\n    PEI <- Canada[Canada@data$NAME_1==\"Prince Edward Island\",]\r\n    plot(PEI,col=\"red\",add=TRUE)\r\n    \r\n    \r\n##### The `maps` and `mapdata` packages for basic maps:\r\n\r\n    \r\nCoordinates which highlight the scale of the map\r\n\r\n    Lat.lim=c(42.5,49)\r\n    Long.lim=c(-69,-59)\r\n    \r\nLocations of interest - these examples correspond to the tips of PEI and the provinces best city####\r\n    \r\n    Site.Longs=c(-61.9,-64,-63.8)\r\n    Site.Lats=c(46.5,47.2,46.4)\r\n    Site.Names=c(\"Souris\",\"Tignish\",\"Summerside\")\r\n    \r\nMake the map. Here you can play with the fill colour (now grey) and a few other tweaks\r\n    \r\n    map(\"worldHires\", xlim=Long.lim, ylim=Lat.lim, col=\"grey\", fill=TRUE, resolution=0);map.axes();\r\n    map.scale(ratio=FALSE) # do you want a scale?\r\n    \r\n    points(Site.Longs,  Site.Lats,pch=19) #Add points if you have data in Site.Longs and Site.lats\r\n    points(-61.6,47.7,pch = 8 ) # this will add point a single point (*) to the Maggies \r\n    text(Site.Longs,Site.Lats,labels=Site.Names,pos=4, offset=0.3) # add labels\r\n    text(-61.6,47.7,labels=\"Ilse de Madeleine\",pos=4, offset=0.3) # add label to an individual plot\r\n    \r\n##### The `ggmap` package for Google Maps:  \r\nThis package is great particularly if you are familiar with the `ggplot2` plotting grammar. You may also come across the `RgoogleMaps` package, but I do not recommend using it because it seems to have a grammar unique to that package (i.e. not compatible with base plotting or ggplot2) and has strange scaling behaviour.\r\n    \r\n    google <- get_map(location = c(-64.4,45.08), zoom = 4, maptype = \"satellite\")\r\n    p <- ggmap(google)\r\n    p + geom_point(aes(x=c(-64.36,-64.4),y=c(45.08,45.1)),colour='yellow',size=3)\r\n\r\n##### The `marmap` package for bathymetry:\r\nIf you're an oceanographer like myself, you will love this package! It can query and plot NOAA's bathymetry databases\r\n    \r\nLet's define some colors for sea and land\r\n    \r\n    blues <- colorRampPalette(c(\"darkblue\", \"cyan\"))\r\n    greys <- colorRampPalette(c(grey(0.4),grey(0.99)))\r\n\r\nWe can query to NOAA databases for bathymetry at 1 minute resultion, but lets do 10 to keep download speeds reasonable.\r\n    \r\n    atl<- getNOAA.bathy(-75,-50,30,60,resolution=10)\r\n    \r\nAfter that's done we can plot some nice 2d and 3d plots (we will cover the details in a later study group)\r\n\r\n    plot.bathy(atl,\r\n               image = TRUE,\r\n               land = TRUE,\r\n               n=0,\r\n               bpal = list(c(0, max(atl), greys(100)),\r\n                           c(min(atl), 0, blues(100))))\r\n\r\n![Image bathymetry](https://github.com/remi-daigle/GIS_mapping_in_R/blob/master/bathy.jpg?raw=true)\r\n    \r\n        \r\n    wireframe(unclass(atl), drape = TRUE,\r\n              aspect = c(1, 0.1),\r\n              scales = list(draw=F,arrows=F),\r\n              xlab=\"\",ylab=\"\",zlab=\"\",\r\n              at=c(min(atl)/100*(99:0),max(atl)/100*(1:99)),\r\n              col.regions = c(blues(100),greys(100)),\r\n              col='transparent')\r\n    \r\n![Image 3d bathymetry](https://github.com/remi-daigle/GIS_mapping_in_R/blob/master/bathy3d.jpg?raw=true)\r\n\r\n    \r\n    wireframe(unclass(atl), shade = TRUE,\r\n              aspect = c(1, 0.1),\r\n              scales = list(draw=F,arrows=F),\r\n              xlab=\"\",ylab=\"\",zlab=\"\")\r\n    \r\n![Image shaded 3d bathymetry](https://github.com/remi-daigle/GIS_mapping_in_R/blob/master/bathy3dshaded.jpg?raw=true)\r\n  \r\n## Other great resources:\r\nhttp://pakillo.github.io/R-GIS-tutorial/#plot\r\n\r\nhttp://www.milanor.net/blog/?p=594\r\n\r\nhttp://www.kevjohnson.org/making-maps-in-r-part-2/\r\n    ","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}